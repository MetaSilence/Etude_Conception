
import numpy as np
import matplotlib.pyplot as plt

indexes = np.arange(1, 6.1, 0.1)
wav = np.arange(4, 22.001, 0.01)
nanoaxis = np.arange(400, 2201, 1)    
irrad = (6.16e5 / (wav ** 5 * (np.exp(2484/(wav * 10 ** 2))-1)))

Q = []
P = [0]
tlmda = []
R = []
power = []

def Q_solver (n, i): #Calculates the value of Q depending on the index i
    tau = (2 * n[i]) / (n[i]+n[i+1])
    gamma = (n[i] - n[i+1]) / (n[i] + n[i+1])
    Q_new = (1 / tau) * np.array([[1, gamma], [gamma, 1]])
    return Q_new

def P_solver(lmda, central_wav): #Calculates the value of P based on lmda
    delta = complex(0, (np.pi/2)*(central_wav/lmda))
    P_new = np.array([[np.exp(delta), 0], [0, np.exp(-delta)]])
    return P_new
    
def power_solver(n):
    
    #Solve for all values of Q that will be required. 
    Q.append(Q_solver(n, 0))
    Q.append(Q_solver(n, 1))
    Q.append(Q_solver(n, 2))
    Q.append(Q_solver(n, 3))
    
    #For every wavelength, perfom the matrix mult to solve for T(lambda)
    for lmda in range(400, 2201):
        P = [0]
        P[0] = P_solver(lmda, 650)
        T = Q[0] @ P[0] @ Q[1] @ P[0] @ Q[2] @ P[0] @ Q[3]     
        G = abs(T[1][0] / T[0][0])
        R.append(G**2)
        T = 1 - G**2
        tlmda.append(T)
        
    #Performs the calculation of     
    wav = np.arange(4, 22.001, 0.01)
    nanoaxis = np.arange(400, 2201, 1)    
    irrad = (6.16e5 / (wav ** 5 * (np.exp(2484/(wav * 10 ** 2))-1)))
    value = np.trapz(tlmda*irrad, nanoaxis)
    T = 0
    tlmda.clear()
    Q.clear()
    P.clear()
    return value

for k in indexes:
    n = [1.33, 1.5, k, 3.2, 3.5]
    power.append(power_solver(n))
    

    
plt.plot(indexes, power)

n = [1.33, 1.5, 2.3, 3.2, 3.5]
power2 = power_solver(n)
value2 = np.trapz(irrad, nanoaxis)
percent = power2/value2 * 100
print(power2)
print(percent)




